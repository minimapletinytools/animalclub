{-# OPTIONS_GHC -fno-warn-orphans #-}

module AnimalClub.SkellygenSpec (
  spec
) where

import           Relude

import           Test.Hspec
import           Test.HUnit
import           Test.QuickCheck
import           Linear.Arbitrary

import           Control.Monad.Extra
import qualified Data.Vector.Generic         as V
import qualified Text.Show
import System.Random
import Lens.Micro.Platform

import           AnimalClub.Animals
import           AnimalClub.Skellygen
import           AnimalClub.Skellygen.Linear hiding (trace)
import           AnimalClub.Skellygen.Mesh
import           AnimalClub.Skellygen.TRS

--import           Debug.Trace

splitSize :: Int -> Gen [Int]
splitSize = unfoldM f where
  f s = do
    if s == 0
      then return Nothing
      else do
        x <- choose (1,s)
        return $ Just (x, s-x)

instance (Arbitrary a, Random a, AnimalFloat a) => Arbitrary (AnimalNode a) where
  arbitrary = sized arb where
    arb n = do
      pos <- arbitrary
      csize <- if n <= 1
        then return []
        else splitSize n
      children <- mapM (\s -> resize s arbitrary) csize
      th <- choose (0.1,10)
      return AnimalNode {
          _name = BoneId "blank" []
          , _boneTrans = Same
          , _pos = Rel pos
          , _thickness = Abs th
          , _isPhantom = False
          , _children = children
        }

-- notably, default instance does not cover ArbTrans case
instance (Arbitrary a) => Arbitrary (BoneTrans a) where
  arbitrary = elements [ReflX, ReflY, ReflZ]

-- | adds up all coordinates in PotatoMesh
-- only for testing
sumPositionsAndNormalsForTesting :: (AnimalFloat a) => PotatoMesh a -> (V3 a, V3 a)
sumPositionsAndNormalsForTesting (PotatoMesh p n _ _) = (V.sum p, V.sum n)


-- | tests the property that coordinates of any mesh generated by flipping an animal node add up to 0
-- N.B. this test does not work for Float as machine roundoff starts compounding and growing ¯\_(ツ)_/¯
prop_flipAnimalNode_Refl :: (AnimalFloat a) => BoneTrans a -> AnimalNode a -> Bool
prop_flipAnimalNode_Refl bt an = r where
  withFlip = asPhantom $ mans "test_root" (relV3 0 0 0) (Abs 1.0)
    [an, flipAnimalNode bt (defTransFlag bt) an]
  pm = generatePotatoMesh . animalNodeToSkellyNode $ withFlip
  (ps,ns) = sumPositionsAndNormalsForTesting pm
  l = case bt of
    ReflX -> _x
    ReflY -> _y
    ReflZ -> _z
    _ -> undefined
  eps = 0.00001
  r = (view l ps < eps) && (view l ns < eps)



-- TODO spins an animal node around several times (total 360 degrees)
-- and checks that all coordinates around spun axis add to 0
--prop_flipAnimalNode_Spin :: Bool

-- | checks that the nodes that got flipped twice match their unflipped values
prop_flipAnimalNode_Twice :: (AnimalFloat a, Epsilon a) => BoneTrans a -> AnimalNode a -> Bool
prop_flipAnimalNode_Twice bt an = r where
  flipOnce = flipAnimalNode bt (defTransFlag bt) an
  flipTwice = flipAnimalNode bt (defTransFlag bt) flipOnce
  pm_orig = generatePotatoMesh . animalNodeToSkellyNode $ an
  pm_flipTwice = generatePotatoMesh . animalNodeToSkellyNode $ flipTwice
  -- cheap way to test if the two meshes are the same
  -- we could prob do better here and test that the two meshes are identical but whatever
  (ps,ns) = sumPositionsAndNormalsForTesting pm_orig
  (ps',ns') = sumPositionsAndNormalsForTesting pm_flipTwice
  r = nearZero (ps - ps') && nearZero (ns - ns')

-- math stuff
-- TODO move to a new file

-- | this only generates "nice" TRS (nothing weird going on in scale component)
instance (Arbitrary a, AnimalFloat a) => Arbitrary (TRS a) where
  arbitrary = do
    t <- arbitrary
    r <- arbitrary
    NonZeroV3 s <- arbitrary
    return $ TRS t r s

prop_mul_TRS_V3 :: TRS Double -> V3 Double -> Bool
prop_mul_TRS_V3 trs v = pass where
  mul_TRS_V3' (TRS pt pr ps) ct = pt ^+^ (pr `rotate` (conv_Scale_M33 ps !* ct))
  p = mul_TRS_V3 trs v
  p' = mul_TRS_V3' trs v
  pass = nearZero (p-p')

prop_fromTo :: V3 Double -> V3 Double -> Bool
prop_fromTo v1 v2 = pass where
  r = fromTo v1 v2
  v2' = r `rotate` v1
  pass = nearZero (v2 `cross` v2')

spec_fromEulerXYZ :: Spec
spec_fromEulerXYZ = do
  it "handles identity properly" $
    assertBool "" $ nearZero (fromEulerXYZ (V3 0 0 0 :: V3 Double) - identityRotation)
  it "handles 90 deg around X properly" $
    assertBool "" $ nearZero (fromEulerXYZ (V3 pio2 0 0) - Quaternion r2o2 (V3 r2o2 0 0)) where
      pio2 = 1.57079632679  :: Double
      r2o2 = 0.70710678118
  -- TODO more useful test cases

spec :: Spec
spec = do
  describe "Skellygen" $ do
    it "satisfies property that reflected node coordinates all add up to 0 in reflected coordinate" $
      property (prop_flipAnimalNode_Refl @Double)
    it "satisfies property that reflecting twice gives the same thing" $
      property (prop_flipAnimalNode_Twice @Double)
  describe "TRS" $ do
    it "mul_TRS_V3 works as expected" $ property $
      prop_mul_TRS_V3
    it "fromTo works as expected" $ property $
      prop_fromTo
    describe "fromEulerXYZ" $
      spec_fromEulerXYZ
